# Lib Dependencies 
1. django  
2. sqlalchemy(next iteration for mock product data, speciment data)
3. jupyternotebook (next iteration for data science analysis)

# Running django project 
1. run ```python manage.py runserver on kidfitness directory in your project 
2. run ```python manage.py createsuperuser on kdfintess directory in project to create super user to add tables of mock data on localhost:8080
3. run ``python manage.py makemigrations and ```python manage.py migrate to apply database migrations.

# Django 
More information on django: 
A Django project's directory structure is designed to organize the various components of a web application. When a new Django project is created using django-admin startproject [projectname], a root directory with the specified project name is generated. This root directory contains essential files and a sub-directory with the same project name, often referred to as the "inner" project directory.
Key components within a Django project's directory structure:
Root Project Directory (e.g., my_project/):
manage.py: A command-line utility for interacting with the Django project. It's used for tasks like running the development server, creating applications, managing migrations, and running tests.
Inner Project Directory (e.g., my_project/my_project/):
__init__.py: An empty file indicating that the directory is a Python package.
settings.py: Contains the project's configuration settings, including database connections, installed applications, middleware, template settings, and static file configurations.
urls.py: Defines the URL patterns for the entire project, mapping URLs to specific views.
wsgi.py: A file used for deploying the Django application with a WSGI-compatible web server.
asgi.py: A file used for deploying the Django application with an ASGI-compatible web server, primarily for handling asynchronous operations and real-time communication.
Application Directories (e.g., my_project/my_app/):
Django projects are typically composed of multiple "apps," which are self-contained modules providing specific functionalities (e.g., a blog app, a user authentication app).
Each app has its own directory containing files like:
models.py: Defines the database models for the application.
views.py: Contains the logic for handling requests and rendering responses.
urls.py: Defines the URL patterns specific to that application.
admin.py: Registers models with the Django admin interface.
migrations/: Contains database migration files generated by Django.
templates/: Stores HTML templates for the application's views.
static/: Stores static files like CSS, JavaScript, and images for the application.
Templates Directory (e.g., my_project/templates/):
Often placed at the root project level, this directory stores project-wide HTML templates, including base templates that other app-specific templates might extend.
Static Files Directory (e.g., my_project/static/):
Often placed at the root project level, this directory stores project-wide static files.
This structured approach promotes modularity, reusability of applications, and maintainability in Django projects.
# project

This project is run on django. future iterations will implement large language models using jupyternotebook and data visuals can be done with mathplot libraries

# For setting up LLM 
1. Building a Large Language Model (LLM) within a Jupyter Notebook environment using Python involves several key steps, whether you are building from scratch, fine-tuning, or customizing.
1. Setting up the Environment:
Install JupyterLab/Jupyter Notebook: Ensure you have a recent version (JupyterLab 4.x or Jupyter Notebook 7+). You can install it using pip:
Code
    pip3 install jupyter
    pip install jupyterlab
Create a Virtual Environment (Recommended): Isolate your project's dependencies to avoid conflicts.
Code

    python -m venv llm_env
    source llm_env/bin/activate  # On Windows: llm_env\Scripts\activate
Install Necessary Libraries: Install libraries for LLM development, such as:
PyTorch or TensorFlow: For building and training models.
Transformers (Hugging Face): For accessing pre-trained models and tools for fine-tuning.
Numpy, Pandas: For data manipulation.
Matplotlib, Seaborn: For data visualization.
Code

    pip install torch transformers numpy pandas matplotlib
Install Jupyter AI (Optional but Recommended): For an enhanced LLM experience within Jupyter, including chat, code generation, and inline completions.
Code

    pip install "jupyter-ai[all]"
# 2. Building or Utilizing the LLM:
Data Preparation:
Load and preprocess your text data within Jupyter Notebook cells. This may involve tokenization, creating embeddings, and preparing input/target pairs.
Model Definition:
From Scratch: Define the architecture of your LLM using frameworks like PyTorch or TensorFlow, including layers like embedding layers, recurrent layers (e.g., GRU, LSTM), and dense layers.
Fine-tuning/Customizing Pre-trained Models: Load a pre-trained model from Hugging Face's Transformers library and fine-tune it on your specific dataset for a particular task (e.g., text generation, summarization).
Training:
Implement the training loop within your notebook, including forward passes, loss calculation, backpropagation, and optimization.
Evaluation:
Evaluate the model's performance on a validation set using appropriate metrics.
3. Interacting with the LLM in Jupyter:
Code Cells:
Write and execute Python code in cells to define, train, and interact with your LLM.
Jupyter AI (if installed):
Utilize the Jupyter AI chat interface for direct interaction with your loaded LLM, or leverage its inline completion and code generation features.
Visualization:
Use libraries like Matplotlib to visualize training progress, attention mechanisms, or other model insights.
By following these steps, you can effectively build, train, and interact with large language models within the interactive and iterative environment of a Jupyter Notebook.